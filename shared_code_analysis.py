import sys
import argparse
import os
import murmur
import shelve
import numpy as np
from similarity_graph import *

NUM_MINHASHES = 256
SKETCH_RATIO = 8
DB_PATH = "/".join(__file__.split('/')[:-1]+['samples.db'])

def wipe_database():
    os.system("rm -f {0}".format(DB_PATH))

def get_database():
    return shelve.open(DB_PATH, protocol = 2, writeback=True)

def minhash(features):
    minhashes = []
    sketches = []
    
    #for feature in features:
        #print("feature")
    
    for num_minhash in range(NUM_MINHASHES):
        minhashes.append(
                min([murmur.string_hash(`feature`, num_minhash) for feature in features])
                )
        #print("this is the min hash array: ", minhashes)
        #raw_input("\npress any key...")
        #continue

    for i in xrange(0,NUM_MINHASHES,SKETCH_RATIO):
        sketch = murmur.string_hash('minhashes[i:i+SKETCH_RATIO]')
        sketches.append(sketch)
       
    return np.array(minhashes),sketches

def store_sample(path):
    db = get_database()
    features = getstrings(path)
    minhashes, sketches = minhash(features)

    for sketch in sketches:
        sketch = str(sketch)
        if not sketch in db:
            db[sketch] = set([path])
        else:
            obj = db[sketch]
            obj.add(path)
            db[sketch] = obj
        db[path] = {'minhashes':minhashes,'comments':[]}
        db.sync()

    print "Extracted {0} features from {1}...".format(len(features),path)

def comment_sample(path):
    db = get_database()
    comment = raw_input("Enter your comment:")
    if not path in db:
        store_sample(path)
    comments = db[path]['comments']
    comments.append(comment)
    db[path]['comments'] = comments
    db.sync()
    print "stored comment:", comment

def search_sample(path):
    db = get_database()
    features = getstrings(path)
    minhashes, sketches = minhash(features)
    neighbors = []

    for sketch in sketches:
        sketch = str(sketch)

        if not sketch in db:
            continue

    for neighbor_path in db[sketch]:
        neighbor_minhashes = db[neighbor_path]['minhashes']
        similarity = (neighbor_minhashes == minhashes).sum() / float(NUM_MINHASHES)
        neighbors.append((neighbor_path, similarity))

    neighbors = list(set(neighbors))
    neighbors.sort(key=lambda entry:entry[1],reverse=True)
    print ""
    print "Sample name".ljust(64),"Shared code estimate"
    for neighbor, similarity in neighbors:
        short_neighbor = neighbor.split("/")[-1]
        comments = db[neighbor]['comments']
        print str("[*] "+short_neighbor).ljust(64),similarity
        for comment in comments:
            print "\t[comment]",comment

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description="""
Simple code-sharing search system which allows you to build up a database of malware samples (indexed by file paths) and
then search for similar samples given some new sample
"""
    )

    parser.add_argument(
        "-l","--load",dest="load",default=None,
        help="Path to directory containing malware, or individual malware file, to store in database"
    )

    parser.add_argument(
        "-s","--search",dest="search",default=None,
        help="Individual malware file to perform similarity search on"
    )

    parser.add_argument(
        "-c","--comment",dest="comment",default=None,
        help="Comment on a malware sample path"
    )

    parser.add_argument(
        "-w","--wipe",action="store_true",default=False,
        help="Wipe sample database"
    )

    args = parser.parse_args()

    if len(sys.argv) == 1:
        parser.print_help()
    if args.load:
        malware_paths = [] # where we'll store the malware file paths
        malware_attributes = dict() # where we'll store the malware strings

        for root, dirs, paths in os.walk(args.load):
            # walk the target directory tree and store all of the file paths
            for path in paths:
                full_path = os.path.join(root,path)
                malware_paths.append(full_path)

        # filter out any paths that aren't PE files
        malware_paths = filter(pecheck, malware_paths)

        # get and store the strings for all of the malware PE files
        for path in malware_paths:
            store_sample(path)

    if args.search:
        search_sample(args.search)

    if args.comment:
        comment_sample(args.comment)

    if args.wipe:
        wipe_database()
